//Environment mapping using Chromatic dispersion based on http://www3.di.uminho.pt/uce-cg/wp-content/uploads/Cube-Mapping-and-GLSL.pdfuniform mat4 transform;uniform mat4 modelview;uniform mat3 normalMatrix;uniform mat4 camMatrix;uniform mat4 texMatrix;const float fresnelPower = 0.5;in vec4 color;in vec4 vertex;in vec3 normal;in vec2 texCoord;out vec3 reflectDir;out vec3 refractDirRed;out vec3 refractDirGreen;out vec3 refractDirBlue;out float refractRatio;out vec4 vertColor;uniform float bias = 0.3;uniform float scale = 2.0;uniform float power = 2.0;void main() {  vertColor = color;  //camera information  vec3 ecNormal =  normalize(normalMatrix * normal);   vec4 ecVertex =  normalize(modelview * vertex);     //Reflection  reflectDir =  reflect(ecVertex.xyz, ecNormal);  vec4 reflectMatrixCorrection = camMatrix * vec4(reflectDir, 0.0);  reflectDir = reflectMatrixCorrection.xyz;  //Refracction  /*commonRatio are : https://en.wikipedia.org/wiki/List_of_refractive_indices  Air   1.00  Water   1.33  Ice   1.309  Glass   1.52  Diamond   2.42*/  float ratio = 1.00 / 2.42;  //Fresnel approximation   float simpleFresnel = 1.0 - pow(dot(-ecVertex.xyz, ecNormal), fresnelPower);  //Schlick approximation  float f = ((1.0-ratio) * (1.0-ratio)) / ((1.0+ratio) * (1.0+ratio));  float schlickRatio = f + (1.0 - f) * pow((1.0 - dot(-normalize(ecVertex.xyz), normalize(ecNormal))), fresnelPower);  schlickRatio = pow(schlickRatio, 4);  //cgTut empirical approximation  float cgApprox = max(0, min(1, bias + scale * pow(1.0 - dot(ecNormal, -ecVertex.xyz), power)));  refractRatio = cgApprox;  refractDirRed =  refract(ecVertex.xyz, ecNormal, ratio);  refractDirGreen =  refract(ecVertex.xyz, ecNormal, ratio + 0.01);  refractDirBlue =  refract(ecVertex.xyz, ecNormal, ratio + 0.02); vec4 refractMatrixRedCorrection = camMatrix  *  vec4(refractDirRed, refractRatio);  vec4 refractMatrixGreenCorrection = camMatrix  *  vec4(refractDirGreen, refractRatio);  vec4 refractMatrixBlueCorrection = camMatrix  *  vec4(refractDirBlue, refractRatio);  refractDirRed = refractMatrixRedCorrection.xyz;  refractDirGreen = refractMatrixGreenCorrection.xyz;  refractDirBlue = refractMatrixBlueCorrection.xyz;    gl_Position = transform * vertex;}